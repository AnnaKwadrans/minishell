Tu shell deberá:
• Mostrar una entrada mientras espera un comando nuevo.
	función readline

• Tener un historial funcional.
	funciones add_history etc.

• Buscar y ejecutar el ejecutable correcto (basado en la variable PATH o mediante el
uso de rutas relativas o absolutas).

• Evita utilizar más de una variable global para indicar la recepción de una señal.
Piensa en lo que implica: Esta aproximación evita que tu gestor de señales acceda
a tus estructuras de datos principales.
	SEÑALES

• No interpretar comillas sin cerrar o caracteres especiales no especificados en el
enunciado como \ (barra invertida) o ; (punto y coma).
	NO ENTIENDO (parseo)

• Gestionar que la ’ evite que el shell interprete los metacaracteres en la secuencia
entrecomillada.
	parseo

• Gestionar que la " evite que el shell interprete los metacaracteres en la secuencia
entrecomillada exceptuando $ (signo de dólar).
	parseo

• Implementar redirecciones:
◦ < debe redirigir input.
◦ > debe redirigir output.
◦ “<<” debe recibir un delimitador, después leer del input de la fuente actual
hasta que una línea que contenga solo el delimitador aparezca. Sin embargo,
no necesita actualizar el historial.
◦ “>>” debe redirigir el output en modo append.

• Implementar pipes (carácter |). El output de cada comando en la pipeline se
conecta a través de un pipe al input del siguiente comando.

• Gestionar las variables de entorno ($ seguidos de caracteres) que deberán expandirse a sus valores.

• Gestionar $?, que deberá expandirse al estado de salida del comando más reciente
ejecutado en la pipeline.
	valor de retorno (exit)

• Gestionar ctrl-C ctrl-D ctrl-\, que deberán funcionar como en bash.
	SEÑALES

• Cuando sea interactivo:
◦ ctrl-C imprime una nueva entrada en una línea nueva.
◦ ctrl-D termina el shell.
◦ ctrl-\ no hace nada.
	SEÑALES

• Deberá implementar los built-ins:
◦ echo con la opción -n.
◦ cd solo con una ruta relativa o absoluta.
◦ pwd sin opciones.
◦ export sin opciones.
◦ unset sin opciones.
◦ env sin opciones o argumentos.
◦ exit sin opciones.

La función readline puede producir algunos leaks que no necesitas arreglar. Eso no
significa que tu código, sí, el código que has escrito, pueda producir leaks.



Parts of a Shell Program
The shell implementation is divided into three parts: The Parser, The Executor, and Shell 
Subsystems.  

The Parser
The Parser is the software component that reads the command line such as “ls ­al” and puts it 
into a data structure called Command Table that will store the commands that will be 
executed.

The Executor
The executor will take the command table generated by the parser and for every 
SimpleCommand in the array it will create a new process. It will also if necessary create pipes 
to communicate the output of one process to the input of the next one. Additionally, it will 
redirect the standard input, standard output, and standard error if there are any redirections. 

Using Lex and Yacc to implement the Parser
You will use two UNIX tools to implement your parser: Lex and Yacc. These tools are used to 
implement compilers, interpreters, and preprocessors. You do not need to know compiler 
theory to use these tools. Everything you need to know about these tools will be explained in 
this chapter. 

A parser is divided into two parts: a Lexical Analyzer or Lexer takes the input characters and 
puts the characters together into words called tokens, and a Parser that processes the 
tokens according to a grammar and build the command table. 
Here is a diagram of the Shell with the Lexer, the Parser and the other components. 

